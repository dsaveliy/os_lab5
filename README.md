# Лабораторная работа: Пайпы

## Задача
Реализована цепочка обработки данных:
`Main` → `M` → `A` → `P` → `S` → `Main`, где `M` , `A` , `P` , `S` - независимые процессы
**Логика работы:**
1. **Main**: Получает строку чисел от пользователя и передаёт её первому процессу
2. **M**: Читает числа, умножает каждое на 7
3. **A**: Прибавляет к числам 9
4. **P**: Возводит числа в куб
5. **S**: Суммирует полученные числа и выводит итоговую сумму
6. **Main**: Получает результат от S и выводит его в консоль
Взаимодействие происходит строго через перенаправление стандартных потоков ввода-вывода (`stdin` / `stdout`), процессы не знают друг о друге.

## Структура проекта
| Файл | Описание | Ключевые функции/механизмы |
|------|----------|----------------------------|
| `Main.cpp` | Управляющая программа. Создаёт пайпы, запускает дочерние процессы, настраивает наследование дескрипторов | `CreatePipe`, `CreateProcessW` (Win) / `pipe`, `fork`, `dup2` (Linux) |
| `M.cpp` | Процесс умножения | `std::cin`, `std::cout` |
| `A.cpp` | Процесс сложения | `std::cin`, `std::cout` |
| `P.cpp` | Процесс возведения в куб | `std::cin`, `std::cout` |
| `S.cpp` | Процесс суммирования | `std::cin`, `std::cout` |

## Особенности реализации
- Использование Wide-типов.
  В лабе по процессам использовал ANSI-версии символов, поэтому тут решил сделать через wide (функции `CreateProcessW`, `STARTUPINFOW`, типы `wchar_t*` (`std::wstring`)
- Пошаговое создание пайпов и управление наследованием.
  Для предотвращения утечек дескрипторов и зависания (deadlock) пайпов реализована строгая логика управления хендлами:
  Пайпы пошагово создаются перед, нужные HANDLE’ы (pipe) stdin/stdout передаются в функцию, а после создания сразу закрываются, чтобы не было утечек.​
- Различия Windows и Linux реализаций.
  В Windows реализация опирается на функцию CreateProcessW, где перенаправление потоков настраивается через структуру STARTUPINFOW, родитель закрывает свои копии хендлов после запуска каждого процесса.
  В Linux же используется парадигма fork() + exec(): родительский процесс полностью клонируется вместе со всеми открытыми дескрипторами, а перенаправление выполняется внутри дочернего процесса с помощью системного вызова dup2, который подменяет стандартные дескрипторы (0 и 1) на нужные концы пайпа перед заменой образа программы, что требует ручного закрытия всех дублирующихся дескрипторов как в родительском, так и в дочернем процессах для корректной передачи сигнала EOF.
- Обработка ошибок и EOF.
  Процессы корректно обрабатывают конец ввода: `getline` автоматически завершается при получении EOF (когда закрыт пишущий конец пайпа).
  Если в середине цепочки (например, в `M`) произошла ошибка парсинга данных, процесс завершается с кодом ошибки и закрывает свой `stdout`. Следующий процесс (`A`) получает EOF, завершается, и так ошибка доходит до `Main`, который фиксирует отсутствие результата.

## Демонстрация работы программы:
### Windows
<img width="555" height="474" alt="image" src="https://github.com/user-attachments/assets/ba9f436d-6dff-41e3-8111-8910fe10e411" />

### Linux
<img width="621" height="373" alt="image" src="https://github.com/user-attachments/assets/195dd890-80f7-461f-9ab5-f23450e2c808" />

